
---

# Project Structure: k8s-sonarqube-demo

This project demonstrates a full CI/CD pipeline with **Jenkins**, **SonarQube**, **Docker**, and **Kubernetes**, using a **sample Java application**.

---

## Top-Level Files

### 1. `Jenkinsfile`

* **Purpose**: Defines the **declarative Jenkins pipeline**.
* **Stages included**:

  1. **Checkout**: Pulls code from GitHub.
  2. **SonarQube Analysis**: Runs static code analysis using SonarQube.
  3. **Build Docker Image**: Builds a Docker image for the app.
  4. **Push Docker Image**: Pushes the image to DockerHub.
  5. **Deploy to Kubernetes**: Updates the deployment in the Kubernetes cluster.
  6. **Verify Deployment**: Checks pod status and service.
* **Environment variables**:

  * `DOCKER_IMAGE` & `DOCKER_TAG`: For Docker image management.
  * `KUBECONFIG_CREDENTIAL`: Optional, used if Jenkins needs cluster access.

---

### 2. `README.md`

* **Purpose**: Documentation for setup, troubleshooting, and CI/CD workflow.
* **Contents**:

  * Architecture diagram.
  * Setup instructions for Jenkins, Kubernetes, and SonarQube.
  * Troubleshooting tips for common issues like `CrashLoopBackOff`, Kubernetes credentials, and Docker image caching.

---

## `app/` Directory

Contains the **Java application** and all related build files.

### 1. `Dockerfile`

* **Purpose**: Containerizes the Java app.
* **Key Steps**:

  * Uses `openjdk:17` base image.
  * Copies `target/app.jar` into `/app.jar` in the container.
  * Sets the container to run `java -jar /app.jar`.
  * Exposes port `8080`.

### 2. `pom.xml`

* **Purpose**: Maven build configuration.
* **Key Details**:

  * Defines dependencies, build plugins, and Java version.
  * Configured to produce a `jar` file with a **Main-Class** for execution.
  * Includes configuration for unit tests and optionally SonarQube scanner integration.

### 3. `src/`

* **Purpose**: Contains Java source code and test code.

#### `main/java/com/demo/App.java`

* **Main application class**.
* Contains the `main()` method.
* Implements the basic logic of the sample application.

#### `test/java/com/demo/AppTest.java`

* **Unit tests** for the application.
* Ensures code correctness using JUnit.

### 4. `target/`

* **Purpose**: Contains all **compiled artifacts** generated by Maven.
* **Subdirectories**:

  * `classes/`: Compiled `.class` files.
  * `test-classes/`: Compiled test classes.
  * `surefire-reports/`: Test execution reports in XML and text formats.
  * `generated-sources/` & `generated-test-sources/`: Auto-generated sources.
  * `maven-status/`: Compilation metadata for Maven plugins.

---

## `k8s/` Directory

Contains **Kubernetes manifests** for deploying the application and SonarQube server.

### 1. `deployment.yaml`

* **Purpose**: Defines the **Deployment** for the application.
* **Key Sections**:

  * `replicas`: Number of pods.
  * `containers`: Docker image and container port.
  * `imagePullPolicy: Always` to ensure the latest image is pulled.
  * Optional labels and selectors for service discovery.

### 2. `service.yaml`

* **Purpose**: Exposes the application via Kubernetes **Service**.
* **Key Details**:

  * Type: `NodePort` (accessible externally on a node port).
  * Selects pods using labels defined in the deployment.

### 3. `sonarqube.yaml`

* **Purpose**: Deploys **SonarQube server** in the cluster.
* **Key Details**:

  * Deployment defines SonarQube container image and port (`9000` or NodePort for external access).
  * Service exposes SonarQube dashboard for Jenkins to send scan results.
* **Integration**: Jenkins pipeline uses the SonarQube token to run scans against this server.

---

## How Everything Works Together

1. **Developer pushes code to GitHub**.
2. **Jenkins pipeline triggers**:

   * Runs **unit tests**.
   * Performs **static code analysis** via SonarQube.
   * Builds **Docker image**.
   * Pushes image to **DockerHub**.
   * Updates Kubernetes deployment with new image.
3. **Kubernetes deployment**:

   * Pulls the latest Docker image.
   * Launches pods.
   * Exposes app through NodePort service.
4. **Verification**:

   * `kubectl get pods` and `kubectl get svc` confirm app is running.
   * SonarQube dashboard shows analysis results.

---

## Key Troubleshooting Notes

* **CrashLoopBackOff**: Check `kubectl logs <pod>`. Usually caused by missing `Main-Class` in JAR.
* **Image caching**: Use unique Docker tags (`v1`, `v2`) to force update.
* **Kubeconfig issues**: Set `KUBECONFIG=/path/to/admin.conf`. Update server IP if private IPs changed.
* **Pods not joining**: Run `kubeadm join` on workers if master IP changes.

---

This README will help you **understand each component, troubleshoot issues, and extend the setup** for future projects.

---


Do you want me to create that PDF?
